#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "SDL2/SDL.h"

#include "lib/freihand/inc/freihand.h"
#include "lib/amoloader/amoloader.h"
#include "lib/mate/inc/mate.h"


struct uniform_buffer {
	mat4_t pos;
	mat4_t rot;
	mat4_t view;
	mat4_t proj;
};

struct camera_compact {
	mat4_t view;
	mat4_t proj;
};



struct stuff {
	struct fh_window *window;
	struct fh_shader *shader;
	struct fh_texture *texture;
	struct fh_camera *cam;


	struct camera_compact camcom; 

	vec3_t rot_a;
	vec3_t rot_b;
	float x;

	struct fh_model *mdl_a;
	struct uniform_buffer unibuf_a;
	struct fh_model *mdl_b;
	struct uniform_buffer unibuf_b;
	struct fh_model *ui;
	struct uniform_buffer unibuf_cam;

	struct fh_flat *flat;
};

void load_model(struct fh_context *ctx, struct stuff *s)
{
	FILE *fd;
	struct amo_model *data;

	int vtxnum;
	float *vtx = NULL;
	float *tex = NULL;
	float *nrm = NULL;

	int idxnum;
	unsigned int *idx = NULL;

	struct fh_model_c *c;

	char *pth = "./res/models/cube.amo";

	vec3_t ini_pos = {0, 0, 0};
	vec3_t ini_rot = {0, 0, 0};


	if(!(fd = fopen(pth, "r"))) {
		printf("Failed to open file\n");
		goto err_return;
	}

	if(!(data = amo_load(fd))) {
		printf("Failed to load model data\n");
		goto err_close_fd;
	}

	amo_getdata(data, &vtxnum, (void **)&vtx, (void **)&tex, (void **)&nrm,
			NULL, NULL, &idxnum, &idx);


	printf("model!\n");

	if(!(c = fh_BeginModelConstr("model_a", vtxnum, idxnum, idx))) {
		printf("Failed to begin construction\n");
		goto err_free_buffers;
	}


	fh_ModelConstrShader(c, "test");
	fh_ModelConstrTexture(c, "brick");

	fh_ModelConstrAttrib(c, "v_pos", 3, GL_FLOAT, vtx);
	fh_ModelConstrAttrib(c, "v_uv", 2, GL_FLOAT, tex);
	fh_ModelConstrAttrib(c, "v_nrm", 3, GL_FLOAT, nrm);

	fh_ModelConstrUniform(c, "camera", sizeof(struct uniform_buffer));


	if(!(s->mdl_a = fh_EndModelConstr(c, ctx, ini_pos, ini_rot))) {
		printf("Failed to finalize construction\n");
		goto err_free_buffers;
	}


	fh_ModelConstrCleanup(c);

	fclose(fd);

	return;

err_free_buffers:
	fh_free(vtx);
	fh_free(tex);
	fh_free(nrm);
	fh_free(idx);

	amo_destroy(data);

err_close_fd:
	fclose(fd);

err_return:
	return;
}


void load_ui(struct fh_context *ctx, struct stuff *s)
{
	struct fh_model_c *c;

	unsigned int vtxnum = 4;
	unsigned int idxnum = 6;

	float vertices[] = {
		-1,  -1,   0,
		-1,   1,   0,
		 1,   1,   0,
		 1,  -1,   0
	};

	/* Texture coordinates (2 floats per vertex) */
	float texCoords[] = {
		0.0f, 0.0f,
		0.0f, 1.0f,
		1.0f, 1.0f,
		1.0f, 0.0f
	};

	float normals[] = {
		0, -1, 0,
		0, -1, 0,
		0, -1, 0,
		0, -1, 0
	};

	/* Indices (3 ints per triangle) */
	unsigned int indices[] = {
		0, 1, 2,
		0, 2, 3
	};

	vec3_t ini_pos = {0, 0, 0};
	vec3_t ini_rot = {0, 0, 0};

	printf("ui!\n");

	if(!(c = fh_BeginModelConstr("ui", vtxnum, idxnum, indices))) {
		printf("Failed to begin construction\n");
		return;
	}

	fh_ModelConstrShader(c, "plane");
	fh_ModelConstrTexture(c, "unt");

	fh_ModelConstrAttrib(c, "v_pos", 3, GL_FLOAT, vertices);
	fh_ModelConstrAttrib(c, "v_uv", 2, GL_FLOAT, texCoords);
	fh_ModelConstrAttrib(c, "v_nrm", 3, GL_FLOAT, normals);

	fh_ModelConstrUniform(c, "camera", sizeof(struct uniform_buffer));

	if(!(s->ui = fh_EndModelConstr(c, ctx, ini_pos, ini_rot))) {
		printf("Failed to finalize construction\n");
		return;
	}

	fh_ModelConstrCleanup(c);
}



void init_stuff(struct stuff *s, struct fh_window *parent, char *name, u32 w, u32 h)
{
	struct fh_shader *flat_shd;
	struct fh_camera_info cam_info;

	struct fh_flat *flat;

	vec3_t pos_a = {5, 0, 0};
	vec3_t pos_b = {-5, 0, 0};

	mat4_idt(s->camcom.view);
	mat4_idt(s->camcom.proj);

	vec3_clr(s->rot_a);
	vec3_clr(s->rot_b);
	s->x = -10;

	s->window = fh_add_window(parent, name, w, h);

	/* Create the UI shader */
	fh_load_shader(s->window, "test", "./res/shaders/model_test.vert", "./res/shaders/model_test.frag");
	fh_load_shader(s->window, "plane", "./res/shaders/plane.vert", "./res/shaders/plane.frag");


	fh_load_texture(s->window, "red", "./res/images/red.png");
	fh_load_texture(s->window, "brick", "./res/images/brick.png");
	fh_load_texture(s->window, "unt", "./res/images/Untitled.png");
	
	load_model_a(s->window, s);

	mat4_idt(s->unibuf_a.pos);
	mat4_pfpos(s->unibuf_a.pos, pos_a);
	mat4_idt(s->unibuf_a.rot);
	mat4_idt(s->unibuf_a.view);
	mat4_idt(s->unibuf_a.proj);

	load_model_b(s->window, s);

	mat4_idt(s->unibuf_b.pos);
	mat4_pfpos(s->unibuf_b.pos, pos_b);
	mat4_idt(s->unibuf_b.rot);
	mat4_idt(s->unibuf_b.view);
	mat4_idt(s->unibuf_b.proj);

	load_ui(s->window, s);

	mat4_idt(s->unibuf_cam.pos);
	mat4_idt(s->unibuf_cam.rot);
	mat4_idt(s->unibuf_cam.view);
	mat4_idt(s->unibuf_cam.proj);



	s->flat = fh_create_flat("test", s->window, 0, 0, 800, 600);

	/* Create a camera */
	cam_info.area_of_view = 60;
	cam_info.aspect_ratio = 800.0f / 600.0f;
	cam_info.near = 0.01;
	cam_info.far = 1000;
	s->cam = fh_create_camera(s->window, "main", cam_info);
}





int main(void) {
	struct fh_event evt;
	struct fh_element *ele;


	struct stuff one;


	srand(time(NULL));

	if(fh_init() < 0)
		goto err_return;
	

	init_stuff(&one, NULL, "Hauptfenster", 800, 600);


	while(fh_update()) {	
		while(fh_pull_event(&evt)) {
		}



		/* ==================================================== */

		one.x -= 0.01;

		one.rot_a[0] += M_PI / 200;
		one.rot_a[1] += M_PI / 100;
		one.rot_a[2] += M_PI / 50;

		one.rot_b[0] -= M_PI / 200;
		one.rot_b[1] -= M_PI / 100;
		one.rot_b[2] -= M_PI / 50;

		fh_activate_window(one.window);
		fh_clear_window(one.window);


		one.cam->pos[1] = one.x;

		fh_cam_update_proj(one.cam);
		fh_cam_update_view(one.cam);


		mat4_rfagl(one.unibuf_a.rot, one.rot_a);
		mat4_rfagl(one.unibuf_b.rot, one.rot_b);
	
		fh_cam_get_proj(one.cam, one.unibuf_a.proj);
		fh_cam_get_view(one.cam, one.unibuf_a.view);

		fh_cam_get_proj(one.cam, one.unibuf_b.proj);
		fh_cam_get_view(one.cam, one.unibuf_b.view);

		fh_mdl_set_uniform(one.mdl_a, "camera", &one.unibuf_a);
		fh_mdl_set_uniform(one.mdl_b, "camera", &one.unibuf_b);
		fh_mdl_set_uniform(one.ui, "camera", &one.unibuf_cam);





		fh_mdl_render(one.mdl_b);

		fh_mdl_render(one.mdl_a);


		fh_mdl_render(one.ui);


		fh_redraw_window(one.window);

		/* ==================================================== */
	}

err_cleanup:
	fh_quit();

err_return:
	return 0;
}

